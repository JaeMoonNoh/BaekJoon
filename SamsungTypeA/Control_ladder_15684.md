# 백준 사다리 조작 15684
[사다리 조작](https://www.acmicpc.net/problem/15684)

### 문제

사다리 게임은 N개의 세로선과 M개의 가로선으로 이루어져 있다. 인접한 세로선 사이에는 가로선을 놓을 수 있는데, 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수는 H이고, 모든 세로선이 같은 위치를 갖는다. 아래 그림은 N = 5, H = 6 인 경우의 그림이고, 가로선은 없다.

초록선은 세로선을 나타내고, 초록선과 점선이 교차하는 점은 가로선을 놓을 수 있는 점이다. 가로선은 인접한 두 세로선을 연결해야 한다. 단, 두 가로선이 연속하거나 서로 접하면 안 된다. 또, 가로선은 점선 위에 있어야 한다.

위의 그림에는 가로선이 총 5개 있다. 가로선은 위의 그림과 같이 인접한 두 세로선을 연결해야 하고, 가로선을 놓을 수 있는 위치를 연결해야 한다.

사다리 게임은 각각의 세로선마다 게임을 진행하고, 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다. 이때, 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다.

위의 그림에서 1번은 3번으로, 2번은 2번으로, 3번은 5번으로, 4번은 1번으로, 5번은 4번으로 도착하게 된다. 아래 두 그림은 1번과 2번이 어떻게 이동했는지 나타내는 그림이다.

사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 세로선의 개수 N, 가로선의 개수 M, 세로선마다 가로선을 놓을 수 있는 위치의 개수 H가 주어진다. (2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)

둘째 줄부터 M개의 줄에는 가로선의 정보가 한 줄에 하나씩 주어진다.

가로선의 정보는 두 정수 a과 b로 나타낸다. (1 ≤ a ≤ H, 1 ≤ b ≤ N-1) b번 세로선과 b+1번 세로선을 a번 점선 위치에서 연결했다는 의미이다.

가장 위에 있는 점선의 번호는 1번이고, 아래로 내려갈 때마다 1이 증가한다. 세로선은 가장 왼쪽에 있는 것의 번호가 1번이고, 오른쪽으로 갈 때마다 1이 증가한다.

입력으로 주어지는 가로선이 서로 연속하는 경우는 없다.

### 출력

i번 세로선의 결과가 i번이 나오도록 사다리 게임을 조작하려면, 추가해야 하는 가로선 개수의 최솟값을 출력한다. 만약, 정답이 3보다 큰 값이면 -1을 출력한다. 또, 불가능한 경우에도 -1을 출력한다.

### 알고리즘 자료구조


단순 구현이고 여러개의 사다리가 주어졌을때 경우의 수를 구하는 것이기 때문에 backTracking을 생각할 수 있다.
그리고 사다리를 어떤 자료구조로 구현해야할까 고민을 상당히 많이 하게됐다. 그래프로 연결하기에는 너무 다양한 경우의 수가 존재한다.
예를 들어 1번 2번이 연결이 두번 되어있으면 두번 연결을 지어야하는데 구현할 수는 있겠지만 너무 효율적이지 못하다고 생각했다.
그래서 사다리를 가장 무난하게 배열로 표현했다.

### 구현해야할 조건

> 사다리가 들어가야할 위치

```c++

	for(int i = y; i < h; i++)
	{
		for(int j = 1; j < n; j++)
		{
			if(!ladder[i][j-1] && !ladder[i][j] && !ladder[i][j+1]) // 좌우에 사다리가 없어야 연결이 가능하다.
			{
				ladder[i][j] = true; // 확인
				DFS(i, cnt+1);
				ladder[i][j] = false; // 취소
			}
		}
	}

```

> 사다리의 개수 카운트


```c++

	for(int i = 0; i <= 3; i++)
	{
		ladderCnt = i; // 총 3개를 구해야하기 때문에 값을 설정
		DFS(0,0);
		
		if(chk)
		{
			cout << ladderCnt << "\n";
			return 0;
		}
	}

```

> 사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다.

```c++

if(cnt == ladderCnt) // 조작하기위해 사용하는 개수가 충족이 되었을때, 좌우 사다리가 없는 위치에
	{
		bool check = true;
		
		for(int i = 1; i <= n; i++)
		{
			int row = i;
			
			for(int j = 0; j < h; j++)
			{
				if(ladder[j][row] && row <= n) // 해당 라인이 true이고, row가 n보다 작거나 같을때는 우측이동
					row++;
				
				else if(row > 1 && ladder[j][row-1]) // 해당 라인이 1보다 크고 좌측값이 true라면 좌측 이동
					row--;
			}
			
			if(i != row)
			{
				check = false;
				break; // 결과적으로 i != row라면 실패가 된다.
			}
		}
		
		if(check)
			chk = true;
			
		return;
	}

```


### 전체 코드


```c++

#include<iostream>
#include<algorithm>

#define MAX 30
using namespace std;

int n,m,h,ladderCnt;
int ladder[MAX][11];
bool chk = false;

void DFS(int y, int cnt)
{
	if(chk)
		return;
		
	if(cnt == ladderCnt)
	{
		bool check = true;
		
		for(int i = 1; i <= n; i++)
		{
			int row = i;
			
			for(int j = 0; j < h; j++)
			{
				if(ladder[j][row] && row <= n) // 해당 라인이 중요하다 그대로 사다리를 타고 내려오는데, true이면 오른쪽 이동
					row++;
				
				else if(row > 1 && ladder[j][row-1]) // 해당 라인으로 내려오는데 좌측에 true가 있다면 이동
					row--;
			}
			
			if(i != row)
			{
				check = false;
				break;
			}
		}
		
		if(check)
			chk = true;
			
		return;
	}

	for(int i = y; i < h; i++)
	{
		for(int j = 1; j < n; j++)
		{
			if(!ladder[i][j-1] && !ladder[i][j] && !ladder[i][j+1])
			{
				ladder[i][j] = true;
				DFS(i, cnt+1);
				ladder[i][j] = false;
			}
		}
	}
	return;
}

int main()
{
	cin >> n >> m >> h;
	
	for(int i = 0; i < m; i++)
	{
		int y,x; // y : row , x : column
		cin >> y >> x;
		
		ladder[y-1][x] = 1;
	}
	
	for(int i = 0; i <= 3; i++)
	{
		ladderCnt = i;
		DFS(0,0);
		
		if(chk)
		{
			cout << ladderCnt << "\n";
			return 0;
		}
	}
	
	cout << -1 << "\n";
	
	return 0;
}

```

### 잡기술1

잡기술은 없고 제발 문제 풀때 집중해서 한 번에 해결하려고 하지 말고, 실수해도 괜찮으니까
몇번이고 코드를 작성해보자~ 코드적는다고 닳는거 아니니까
